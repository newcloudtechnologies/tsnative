#!/usr/bin/env python3
#
# Copyright (c) New Cloud Technologies, Ltd., 2014-2022
#
# You can not use the contents of the file in any way without
# New Cloud Technologies, Ltd. written permission.
#
# To obtain such a permit, you should contact New Cloud Technologies, Ltd.
# at http://ncloudtech.com/contact.html
#

import os
import re
import subprocess
import platform


def env(var):
    try:
        return os.environ[var]
    except KeyError:
        print("Environment variable required: %s" % var)
        exit(1)


def isCI():
    result = False

    try:
        CI = os.environ["CI"]
        result = not (CI == "" or CI == "False" or CI == "false")
    except KeyError:
        pass

    return result


class PrettyPrinter:
    """
    A class represents printing to terminal with formatting and coloring.

    Method text() prints string without end line to terminal.
    Method endline() returns carriage.
    Each color-method should be closed by invoking endcolor() method.
    Style-methods have the same rule: endstyle() method closes the current style.

    """
    class Colors:
        PURPLE = "\033[95m"
        BLUE = "\033[94m"
        CYAN = "\033[96m"
        GREEN = "\033[92m"
        YELLOW = "\033[93m"
        RED = "\033[91m"
        _END = "\033[0m"

    class Styles:
        BOLD = "\033[1m"
        UNDERLINE = "\033[4m"
        _END = "\033[0m"

    def __init__(self, pretty: bool = True):
        self.pretty = pretty

    def text(self, text):
        print(text, end='')
        return self

    def endline(self):
        print("")
        return self

    def color(self, c: Colors):
        if self.pretty:
            print(f"{c}", end='')
        return self

    def endcolor(self):
        if self.pretty:
            print(f"{PrettyPrinter.Colors._END}", end='')
        return self

    def purple(self):
        return self.color(PrettyPrinter.Colors.PURPLE)

    def blue(self):
        return self.color(PrettyPrinter.Colors.BLUE)

    def cyan(self):
        return self.color(PrettyPrinter.Colors.CYAN)

    def green(self):
        return self.color(PrettyPrinter.Colors.GREEN)

    def yellow(self):
        return self.color(PrettyPrinter.Colors.YELLOW)

    def red(self):
        return self.color(PrettyPrinter.Colors.RED)

    def style(self, s: Styles):
        if self.pretty:
            print(f"{s}", end='')
        return self

    def endstyle(self):
        if self.pretty:
            print(f"{PrettyPrinter.Styles._END}", end='')
        return self

    def bold(self):
        return self.style(PrettyPrinter.Styles.BOLD)

    def underline(self):
        return self.style(PrettyPrinter.Styles.UNDERLINE)


class Comparator:
    """
    A class compares two files running diff command.

    Output values store in stdout and stderr fields.
    """

    def __init__(self, output: str, snippet: str):
        self.__output = output
        self.__snippet = snippet
        self.stdout = ""
        self.stderr = ""

    def __run(self):
        if platform.system() == "Darwin":
            command = ["bash", "-c", "diff -B -b %s %s ; exit 0" %
                       (self.__snippet, self.__output)]
        else:
            command = ["bash", "-c", "diff -Z %s %s ; exit 0" %
                       (self.__snippet, self.__output)]

        result = subprocess.run(
            command, stdout=subprocess.PIPE, stderr=subprocess.PIPE)

        self.stdout = result.stdout.decode("utf-8")
        self.stderr = result.stderr.decode("utf-8")

    def matches(self):
        self.__run()
        return len(self.stdout) == 0 and len(self.stderr) == 0


SCENARIO = env("SCENARIO")
OUTPUTS_FILE = env("OUTPUTS_FILE")
SNIPPETS_FILE = env("SNIPPETS_FILE")
KNOWN_ISSUES_DIR_NAME = env("KNOWN_ISSUES")

print("Comparator started...")
print("OS detected: %s" % platform.system())

if isCI():
    print("CI detected...")

print("Current scenario: %s" % SCENARIO)

with open(OUTPUTS_FILE, "r") as file:
    outputs = "".join(file.read().splitlines()).split(";")

with open(SNIPPETS_FILE, "r") as file:
    snippets = "".join(file.read().splitlines()).split(";")

assert len(outputs) == len(
    snippets), "Comparator failed: quantity of outputs and snippets must be same"

n_matches = 0
current_known_issues = 0
fixed_known_issues = 0

printer = PrettyPrinter(pretty=not isCI())

for i in range(len(outputs)):
    output = outputs[i]

    basename = os.path.basename(output)
    is_known_issue = os.path.dirname(output).endswith(KNOWN_ISSUES_DIR_NAME)

    # find snippet with the same base name
    # we need to have a pair of files: output file (generated by declarator)
    # and snipped file (reference file to compare)
    snippet = next((x for x in snippets if re.search(
        r".*(?:\/|\\)%s" % basename, x)), None)

    assert snippet, "Comparator failed: snippet with name ending %s does not exist" % basename

    comparator = Comparator(output, snippet)

    printer.bold().blue().text(basename.ljust(60, '.')).endcolor().endstyle()

    if is_known_issue and comparator.matches():
        fixed_known_issues += 1
        printer.cyan().bold().text("FIXED").endstyle().endcolor().endline()
    elif is_known_issue and not comparator.matches():
        current_known_issues += 1
        printer.yellow().bold().text("KNOWN").endstyle().endcolor().endline()
    elif comparator.matches():
        n_matches += 1
        printer.green().bold().text("OK").endstyle().endcolor().endline()
    else:
        printer.red().bold().text("FAIL").endstyle().endcolor().endline()

        printer.cyan().underline().text("output:").endstyle(
        ).endcolor().text(output).endcolor().endline()

        printer.cyan().underline().text("snippet:").endstyle(
        ).endcolor().text(snippet).endcolor().endline()

        if len(comparator.stdout) > 0:
            printer.cyan().underline().text("stdout:").endstyle().endcolor().endline(
            ).yellow().text(comparator.stdout).endcolor().endline()

        if len(comparator.stderr) > 0:
            printer.cyan().underline().text("stderr:").endstyle().endcolor().endline(
            ).yellow().text(comparator.stderr).endcolor().endline()

if n_matches + fixed_known_issues + current_known_issues < len(outputs):
    exit(1)
